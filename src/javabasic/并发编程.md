![20231212222527.png](attachments/并发编程/20231212222527.png)

# 线程基础
## 线程和进程
![20231212232440.png](attachments/并发编程/20231212232440.png)

## 并行和并发
![20231212232556.png](attachments/并发编程/20231212232556.png)
![20231212232619.png](attachments/并发编程/20231212232619.png)

## 创建线程的方式
- 继承Thread类
  ![20231213081026.png](attachments/并发编程/20231213081026.png)
- 实现Runnable接口
  ![20231213081047.png](attachments/并发编程/20231213081047.png)
- 实现Callable接口
  ![20231213081117.png](attachments/并发编程/20231213081117.png)
- 线程池创建线程（项目中使用方式）
  ![20231213081202.png](attachments/并发编程/20231213081202.png)

### Runnable和 Callable区别
![20231213084425.png](attachments/并发编程/20231213084425.png)

### 线程的run() 和 start()区别

![20231213084517.png](attachments/并发编程/20231213084517.png)
## ============
![20231213084615.png](attachments/并发编程/20231213084615.png)

## 线程的状态
![20231213084832.png](attachments/并发编程/20231213084832.png)
![20231213085301.png](attachments/并发编程/20231213085301.png)
## ===========
![20231213085746.png](attachments/并发编程/20231213085746.png)

## 新建T1、T2、T3三个线程，保证顺序执行
![20231213090620.png](attachments/并发编程/20231213090620.png)
## notify() 和 notifyAll()区别
- notifyAll: 唤醒所有wait的线程
- notify：只随机唤醒一个wait线程

## java中的wait和sleep方法区别
![20231213091205.png](attachments/并发编程/20231213091205.png)

## 如何停止一个正在运行的线程
![20231213093329.png](attachments/并发编程/20231213093329.png)

# 线程中并发安全

## sychronized关键字的底层原理
![20231213094619.png](attachments/并发编程/20231213094619.png)

![20231213095028.png](attachments/并发编程/20231213095028.png)
### ==========
![20231213095140.png](attachments/并发编程/20231213095140.png)
### 对象的内存结构
![20231213095700.png](attachments/并发编程/20231213095700.png)
### MarkWord
![20231213095759.png](attachments/并发编程/20231213095759.png)
### Monitor重量级锁
![20231213095923.png](attachments/并发编程/20231213095923.png)
### 轻量级锁
![20231213100216.png](attachments/并发编程/20231213100216.png)
![20231213101027.png](attachments/并发编程/20231213101027.png)
![20231213101143.png](attachments/并发编程/20231213101143.png)

### 偏向锁
![20231213101518.png](attachments/并发编程/20231213101518.png)
![20231213101729.png](attachments/并发编程/20231213101729.png)
### ============
![20231213101935.png](attachments/并发编程/20231213101935.png)

## JMM
![20231213103256.png](attachments/并发编程/20231213103256.png)
### ======
![20231213103948.png](attachments/并发编程/20231213103948.png)

## CAS
![20231213104112.png](attachments/并发编程/20231213104112.png)
### =======
![20231213105008.png](attachments/并发编程/20231213105008.png)

## volatile
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，具备了两层语义
- 保证线程间的可见性

**用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见

![20231213144420.png](attachments/并发编程/20231213144420.png)
-  禁止进行指令重排序
   ![20231213145804.png](attachments/并发编程/20231213145804.png)
## ==========
![20231213145940.png](attachments/并发编程/20231213145940.png)

## AQS
![20231213150143.png](attachments/并发编程/20231213150143.png)
![20231213163316.png](attachments/并发编程/20231213163316.png)
## =========
![20231213163413.png](attachments/并发编程/20231213163413.png)

## ReentrantLock的实现原理
![20231213163731.png](attachments/并发编程/20231213163731.png)
### 利用CAS+ AQS队列来实现

![20231213163903.png](attachments/并发编程/20231213163903.png)
![20231213164106.png](attachments/并发编程/20231213164106.png)
## ===========
![20231213164258.png](attachments/并发编程/20231213164258.png)
## sychronized和Lock区别
![20231213165125.png](attachments/并发编程/20231213165125.png)

## 死锁
- 一个线程需要同时获取多把锁，这时就容易发生死锁

### 死锁诊断
**jps 和 jstack**
- jps：输出JVM中运行的进程状态信息
- jstack：查看java进程内线程的堆栈信息
  ![20231213172155.png](attachments/并发编程/20231213172155.png)
  ![20231213172353.png](attachments/并发编程/20231213172353.png)
## ========
![20231213172413.png](attachments/并发编程/20231213172413.png)

## ConcurrentHashMap
![20231213172532.png](attachments/并发编程/20231213172532.png)
![20231213173007.png](attachments/并发编程/20231213173007.png)
![20231213172948.png](attachments/并发编程/20231213172948.png)
## =======
![20231213173138.png](attachments/并发编程/20231213173138.png)
## 导致并发程序出现问题的根本原因
Java并发编程三大特性
- 原子性
-  Sychronized：同步加锁
- JUC里面的lock：加锁
  ![20231213175219.png](attachments/并发编程/20231213175219.png)
- 可见性
  ![20231213175451.png](attachments/并发编程/20231213175451.png)
- 有序性
  ![1702461325260.png](attachments/并发编程/1702461325260.png)
## ========
![20231213175633.png](attachments/并发编程/20231213175633.png)

# 线程池
## 说一下线程池的核心参数
![20231213180631.png](attachments/并发编程/20231213180631.png)
## 线程池的执行原理
![20231213180830.png](attachments/并发编程/20231213180830.png)
## 线程池中有哪些常见的阻塞队列
![20231213185731.png](attachments/并发编程/20231213185731.png)
![20231213185846.png](attachments/并发编程/20231213185846.png)

## 如何确定核心线程数
![20231213190041.png](attachments/并发编程/20231213190041.png)
## ========
![20231213190134.png](attachments/并发编程/20231213190134.png)

## 线程池的种类
1.创建使用固定线程数的
![20231213190421.png](attachments/并发编程/20231213190421.png)
![20231213190456.png](attachments/并发编程/20231213190456.png)
![20231213190548.png](attachments/并发编程/20231213190548.png)
![20231213190716.png](attachments/并发编程/20231213190716.png)
## =========
![20231213190730.png](attachments/并发编程/20231213190730.png)

## 为什么不建议用Executor创建线程池
![20231213191007.png](attachments/并发编程/20231213191007.png)

## 线程池使用场景（CountDownLatch、Future）
### CountDownLatch
![20231213191208.png](attachments/并发编程/20231213191208.png)

## 多线程使用场景一（es数据批量导入）
![20231213191440.png](attachments/并发编程/20231213191440.png)
![20231213191558.png](attachments/并发编程/20231213191558.png)
## 多线程使用场景二（数据汇总）
![20231213192454.png](attachments/并发编程/20231213192454.png)
**Future**![20231213192835.png](attachments/并发编程/20231213192835.png)
![20231213192940.png](attachments/并发编程/20231213192940.png)
## 多线程使用场景三（异步调用）
![20231213193436.png](attachments/并发编程/20231213193436.png)
## ===========
![20231213193423.png](attachments/并发编程/20231213193423.png)

## 如何控制某个方法允许并发访问线程的数量
### Semaphore
**信号量**
![20231213193624.png](attachments/并发编程/20231213193624.png)
![20231213193729.png](attachments/并发编程/20231213193729.png)

## 对ThreadLocal的理解
![20231213193840.png](attachments/并发编程/20231213193840.png)
![20231213194115.png](attachments/并发编程/20231213194115.png)
### ThreadLocal的实现原理
![20231213194157.png](attachments/并发编程/20231213194157.png)
![20231213194320.png](attachments/并发编程/20231213194320.png)
![20231213194401.png](attachments/并发编程/20231213194401.png)

### ThreadLocal-内存泄露问题
![20231213194502.png](attachments/并发编程/20231213194502.png)
![20231213194554.png](attachments/并发编程/20231213194554.png)
## ======
![20231213194657.png](attachments/并发编程/20231213194657.png)