![20231211145448.png](attachments/消息中间件/20231211145448.png)

# RabbitMQ
## 如何保证消息不丢失

![20231211145657.png](attachments/消息中间件/20231211145657.png)
### 生产者确认机制
![20231211145829.png](attachments/消息中间件/20231211145829.png)
### 消息持久化
![20231211145859.png](attachments/消息中间件/20231211145859.png)
### 消费者确认
![1702281207190.png](attachments/消息中间件/1702281207190.png)
### ===============
![20231211155421.png](attachments/消息中间件/20231211155421.png)

## RabbitMQ 消息的重复消费问题
- 每条消息设置一个唯一的标识id
- 幂等方案：【分布式锁、数据锁（悲观锁、乐观锁）】
  ![20231211165534.png](attachments/消息中间件/20231211165534.png)

## RabbitMQ中死信交换机（RabbitMQ延迟队列）
延迟队列 = 死信交换机+ TTL（生存时间）
![20231211184014.png](attachments/消息中间件/20231211184014.png)
![20231211184021.png](attachments/消息中间件/20231211184021.png)
## ========
![20231211184525.png](attachments/消息中间件/20231211184525.png)


## RabbitMQ如果有100万消息堆积在MQ，如何解决
![20231211184734.png](attachments/消息中间件/20231211184734.png)
## ==========
![20231211184853.png](attachments/消息中间件/20231211184853.png)

## RabbitMQ的高可用机制
![20231211185610.png](attachments/消息中间件/20231211185610.png)

# Kafka

## 如何保证消息不丢失
![20231211185926.png](attachments/消息中间件/20231211185926.png)
![20231211190120.png](attachments/消息中间件/20231211190120.png)
![20231211190228.png](attachments/消息中间件/20231211190228.png)
![20231211190538.png](attachments/消息中间件/20231211190538.png)
异步提交 + 同步提交的方式 保证
![20231211190633.png](attachments/消息中间件/20231211190633.png)

## ==================
![20231211190840.png](attachments/消息中间件/20231211190840.png)

## 如何保证消息的顺序性
![20231211191059.png](attachments/消息中间件/20231211191059.png)
## Kafka的高可用
### 分区备份机制

![20231211191247.png](attachments/消息中间件/20231211191247.png)
![20231211191347.png](attachments/消息中间件/20231211191347.png)

## =============
![20231211191538.png](attachments/消息中间件/20231211191538.png)

## Kafka数据清理机制
![20231211191715.png](attachments/消息中间件/20231211191715.png)

## Kafka 中实现高性能的设计
![20231211192045.png](attachments/消息中间件/20231211192045.png)