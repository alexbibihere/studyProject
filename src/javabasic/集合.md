![20231211220117.png](attachments/集合/20231211220117.png)
# 数据结构
- 数组
- 链表
- 二叉树
- 红黑树
- 散列表

# 时间复杂度
**复杂度分析就是要弄清楚代码的执行次数和数据规模n之间的关系**

## O(1)
![20231212094802.png](attachments/集合/20231212094802.png)
## O(n)  O(n2)
![20231212103323.png](attachments/集合/20231212103323.png)
## O(log n)
![20231212103642.png](attachments/集合/20231212103642.png)

# 空间复杂度

空间复杂度全称是渐进空间复杂度，表示算法占用的额外存储空间与数据规模直接的增长关系
![20231212104218.png](attachments/集合/20231212104218.png)

# 数组
## 数组的时间复杂度（查找）
![20231212143113.png](attachments/集合/20231212143113.png)
![20231212143307.png](attachments/集合/20231212143307.png)

## ArrayList 源码分析
### 第一次添加数据
![20231212144656.png](attachments/集合/20231212144656.png)
![20231212144904.png](attachments/集合/20231212144904.png)

### 第十一次添加数据
![20231212145016.png](attachments/集合/20231212145016.png)


### ArrayList底层的实现原理
![20231212145134.png](attachments/集合/20231212145134.png)

## 如何实现数组和List之间的转换
![20231212150652.png](attachments/集合/20231212150652.png)

# 链表
## 单向链表
### **时间复杂度分析**
#### 查询
![20231212151042.png](attachments/集合/20231212151042.png)
#### 插入\删除
![20231212151145.png](attachments/集合/20231212151145.png)

## 双向链表
![20231212152747.png](attachments/集合/20231212152747.png)

### **时间复杂度分析**
![20231212152920.png](attachments/集合/20231212152920.png)

**时间复杂度分析**
![20231212153245.png](attachments/集合/20231212153245.png)

# ArrayList和LinkedList的区别
![20231212153504.png](attachments/集合/20231212153504.png)
![20231212153555.png](attachments/集合/20231212153555.png)

# HashMap
- 二叉树
  ![20231212155346.png](attachments/集合/20231212155346.png)
  ![20231212155708.png](attachments/集合/20231212155708.png)
  ![20231212155914.png](attachments/集合/20231212155914.png)
- 红黑树
  ![20231212165545.png](attachments/集合/20231212165545.png)
  ![20231212170427.png](attachments/集合/20231212170427.png)
  ![20231212170447.png](attachments/集合/20231212170447.png)
- 散列表
  ![20231212174255.png](attachments/集合/20231212174255.png)
  ![20231212174820.png](attachments/集合/20231212174820.png)
![20231212175714.png](attachments/集合/20231212175714.png)

#### 散列冲突-链表法-时间复杂度
**插入操作**   O(1)
![20231212180052.png](attachments/集合/20231212180052.png)
将链表法中的链表改造红黑树 可以防止DDos攻击
## ===============

![20231212180230.png](attachments/集合/20231212180230.png)

## HashMap的实现原理
![20231212182242.png](attachments/集合/20231212182242.png)
## =============
![20231212182510.png](attachments/集合/20231212182510.png)
## HashMap的put方法具体流程
![20231212183443.png](attachments/集合/20231212183443.png)

![20231212183809.png](attachments/集合/20231212183809.png)

## HashMap的扩容机制
![20231212183906.png](attachments/集合/20231212183906.png)
![20231212184149.png](attachments/集合/20231212184149.png)

## HashMap 的寻址算法
![20231212184454.png](attachments/集合/20231212184454.png)

## HashMap在1.7 情况下的多线程死循环问题
![20231212184714.png](attachments/集合/20231212184714.png)